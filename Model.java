package Bayan;

import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.*;

public class Model {
	ArrayList<Float> data;
	ArrayList<OffsetDateTime> date;
	ArrayList<Float> data_range;
	ArrayList<ArrayList<Float>> groupedData;
	ArrayList<Float> smallGroup;
	ArrayList<ArrayList<Integer>> consumption_in_group;
	ArrayList<Integer> consumption_in_group_small;
	ArrayList<ArrayList<Integer>> Weight;
	ArrayList<ArrayList<Double>> posterior;
	Set<Integer> unique;
	Float Max;
	Float Min;

	Model(GetData Temp1) {

		this.data = (ArrayList<Float>) Temp1.data;
		this.date = (ArrayList<OffsetDateTime>) Temp1.date;
		this.data_range = new ArrayList<Float>();
		this.groupedData = new ArrayList<ArrayList<Float>>();
		this.smallGroup = new ArrayList<Float>();
		this.consumption_in_group = new ArrayList<ArrayList<Integer>>();
		this.consumption_in_group_small = new ArrayList<Integer>();
		this.Weight = new ArrayList<ArrayList<Integer>>();
		this.posterior=new ArrayList<ArrayList<Double>>();
		this.Max = (float) 0;
		this.Min = (float) 0;
		this.get_max_min();
		this.get_data_range();
		this.make_group();
		this.PutDataToGroup();
		this.get_probablity_of_data();
		this.Posterior();

	}
////** This method gives max and min value of consumption data**////
//**example data=[[1,3,2,5,4,6]**//
	// **output--->sets Max=6, Min=1**//

	public void get_max_min() {

		this.Max = Collections.max(this.data);
		this.Min = Collections.min(this.data);

	}

////** Using the max and mean identified from above method, this method generates one D array**////
////The value in list starts from min and goes up to max+1 with one increment in each step////
////**Example Max=6, Min=1**////	
//**output--->data_range=[1,2,3,4,5,7]**//
	public void get_data_range() {
		try {

			Float i = this.Min;
			while (i <= this.Max + 2) {
				this.data_range.add(i);
				i = i + 1;
			}
		} catch (Exception ex) {
			ex.printStackTrace();
		}

	}
////** This method converts the one D array generated by above method to 2 D array**////
////**example [1,2,3,4,5,6,7]////
////Output--->[[1,2],[2,3],[3,4],[4,5][5,6],[6,7]**////

	public void make_group() {
		try {

			int small_group_size = 2;

			for (int i = 0; i < (this.data_range.size() - small_group_size); i++) {
				this.smallGroup = new ArrayList<Float>();
				for (int j = 0; j < small_group_size; j++) {
					this.smallGroup.add(this.data_range.get(i + j));
				}
				// i=i+small_group_size-1;

				this.groupedData.add(this.smallGroup);

			}
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}

////** This method Maps our consumption data to a group **////
////**example data=[1,3,2,5,4,6] groupedData=[[1,2],[2,3],[3,4],[4,5][5,6][6,7]**////
//**Output--->[[0],[2],[1],[4],[3],[5]]**//
//(one kw load falls in 1st group, 3kw load falls in third group..... and so on)
	public void PutDataToGroup() {

		///int total_number_of_group = this.groupedData.size();
		for (int i = 0; i < (this.data.size()); i++) {
			for (int j = 0; j < (this.groupedData.size()); j++) {
				if (this.data.get(i) >= Collections.min(this.groupedData.get(j))
						&& this.data.get(i) < Collections.max(this.groupedData.get(j))) {

					this.consumption_in_group_small.add(j);
					

				} else {
				}
				

			}
			// this.consumption_in_group.add(this.consumption_in_group_small);
			// this.consumption_in_group_small = new ArrayList<Integer>();

		}
		
	}

	public void get_probablity_of_data() {

		Set<Integer> unique = new HashSet<Integer>(this.consumption_in_group_small);
		//System.out.println(unique);
		Iterator<Integer> iter = unique.iterator();

		while (iter.hasNext()) {
			ArrayList<Integer> temp1 = new ArrayList<Integer>();
			int temp = iter.next();
			for (int i = 0; i < this.consumption_in_group_small.size(); i++) {

				if (temp == this.consumption_in_group_small.get(i)) {
					temp1.add(i);

				} else {
				}

			}
			this.Weight.add(temp1);

		}
//		System.out.println("This is unique");
//		System.out.println(unique.size());

	}

	public void Posterior() {

		for (int i = 0; i < this.Weight.size(); i++) {
			ArrayList<Double> temp2 = new ArrayList<Double>();

			for (int j = 0; j < this.Weight.get(i).size(); j++) {
				double Probablity_of_consumption =  (double) this.Weight.get(i).size()/ this. consumption_in_group_small.size();
			    //System.out.println(Probablity_of_consumption);
			double Probablity_of_date_given_consumption = (double) Probablity_of_consumption * 1 /  this.Weight.get(i).size();
			//System.out.println(Probablity_of_date_given_consumption);
			temp2.add( Probablity_of_date_given_consumption);

			}
			this.posterior.add(temp2);

		}
//		System.out.println("This is grouped data size");
//		System.out.println(this.groupedData.get(0));
//		System.out.println("This is data size");
//		System.out.println(this.data.size());
//		System.out.println("this is consumption in group");
//		System.out.println(this.consumption_in_group_small.get(8439));
//		System.out.println("This is weight");
//		System.out.println(this.Weight.size());
		
		
	}
	
}
// Weight variable contains where the groups appears in data
// posterior variable contains p(date_time|consumption)
